\chapter{Конструкторский раздел}

В этом разделе будет представлено описание используемых типов данных, а также схематические изображения алгоритмов матричного умножения: 
стандартного, Штрассена, алгоритма Винограда и оптимизированного алгоритма Винограда.

\section{Требования к программному обеспечению}

Программа должна поддерживать два режима работы: режим массового замера времени и режим умножения матриц.

Режим массового замера времени должен обладать следующей функциональностью:
\begin{itemize}
	\item генерировать матрицы различного размер для проведения замеров;
	\item осуществлять массовый замер, используя сгенерированные данные;
	\item результаты массового замера должны быть представлены в виде таблицы и графика.
\end{itemize}

К режиму умножения матриц выдвигается ряд требований:
\begin{itemize}
	\item возможность работать с матрицами разного размера, которые вводит пользователь;
	\item наличие интерфейса для выбора действий;
	\item проверять возможность умножения матриц.
\end{itemize}

\section{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие структуры и типы данных:
\begin{itemize}
	\item целые числа представляют количество строк и столбцов;
	\item матрица --- двумерный список вещественных чисел.
\end{itemize}

\section{Разработка алгоритмов}

На рисунке \ref{img:classic} представлена схема классического алгоритма, выполняющего умножение двух матриц. 
На рисунках \ref{img:vinograd} -- \ref{img:colfactor} изображены схемы алгоритма Винограда без оптимизаций. 
На рисунках \ref{img:strassen} и \ref{img:msr} изображены схемы алгоритмов, которые реализуют алгоритм умножения матриц Штрассена.  
На рисунках \ref{img:vinograd_opt} -- \ref{img:colfactor_opt} изображены схемы алгоритма Винограда с оптимизациями.

\clearpage

\includeimage
{classic} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Классический алгоритм умножения матриц} % Подпись рисунка


\includeimage
{vinograd} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.9\textwidth} % Ширина рисунка
{Алгоритм умножения матриц Винограда} % Подпись рисунка

\includeimage
{rowfactor} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма для вспомогательной подпрограммы, вычисляющей массив вспомогательных значений по строкам} % Подпись рисунка

\includeimage
{colfactor} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма для вспомогательной подпрограммы, вычисляющей массив вспомогательных значений по столбцам} % Подпись рисунка

\includeimage
{strassen} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Алгоритм умножения матриц Штрассена} % Подпись рисунка

\includeimage
{msr} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма подпрограммы MSR, вычисляющей результат умножения матриц по алгоритму Штрассена} % Подпись рисунка

\includeimage
{vinograd_opt} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Алгоритм умножения матриц Винограда с оптимизациями} % Подпись рисунка

\includeimage
{rowfactor_opt} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма для вспомогательной подпрограммы, вычисляющей массив вспомогательных значений по строкам с оптимизациями} % Подпись рисунка

\includeimage
{colfactor_opt} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма для вспомогательной подпрограммы, вычисляющей массив вспомогательных значений по столбцам с оптимизациями} % Подпись рисунка

\clearpage

\section{Оценка трудоемкости алгоритмов}

Введем модель для оценки трудоемкости алгоритмов.
\begin{enumerate}
	\item $+, -, =, +=, -=, ==, ||, \&\&, <, >, <=, >=, <<, >>, []$ --- считаем, что эти операции обладают трудоемкостью в 1 единицу.
	\item $*, /, *=, /=, \% $ --- считаем, что эти операции обладают трудоемкостью в 2 единицы.
	\item Трудоемкость условного перехода примем за $0$.
	\item Трудоемкость условного оператора рассчитывается по следующей формуле
	
	\begin{equation}
		\label{eq:if}
		f_{if} = f_{\text{условия}} + 
		\begin{cases}
			min(f_1, f_2), & \text{лучший случай}\\
			max(f_1, f_2), & \text{худший случай}
		\end{cases},
	\end{equation}
	
	где $f_1$ --- трудоемкость блока, который вычисляется при выполнении условия, а $f_2$ --- трудоемкость блока, который вычисляется при невыполнении условия.
	\item Трудоемкость цикла рассчитывается по формуле
	
	\begin{equation}
		\label{eq:for}
		\begin{gathered}
			f_{for} = f_{\text{инициализация}} + f_{\text{сравнения}} + M_{\text{итераций}} \cdot (f_{\text{тело}} +\\
			+ f_{\text{инкремент}} + f_{\text{сравнения}})
		\end{gathered}
	\end{equation}
	
	\item Вызов подпрограмм и передачу параметров примем за $0$.
\end{enumerate}

\subsection{Трудоемкость классического алгоритма}

Трудоемкость классического алгоритма складывается из следующих слагаемых.
\begin{enumerate}
	\item Внешний цикл по $i \in [0 \ldots N)$ , трудоёмкость которого: $f_{i} = 2 + N \cdot (2 + f_{j})$.
	\item Цикла по $j \in [0 \ldots L)$, трудоёмкость которого: $f_{j} = 2 + L \cdot (2 + f_{k})$.
	\item Цикла по $k \in [0 \ldots Q)$, трудоёмкость которого: $f_{k} = 2 + Q \cdot (2 + 2 + 1 + 2 + 2 + 2) = 2 + 11Q$.
\end{enumerate}

\clearpage
Тогда в итоге, трудоемкость классического алгоритма рассчитывается по формуле

\begin{equation}
	\label{eq:classic_compl}
	f_{classic} = 2 + N \cdot (2 + 2 + L \cdot (2 + 2 + 11Q)) = 11NLQ + 4NL + 4N + 2
\end{equation}

\subsection{Трудоемкость алгоритма Винограда}

Трудоемкость алгоритма Винограда формируется из следующих частей.
\begin{enumerate}
	\item Трудоемкости вычисления массива $RowFactor$, которая рассчитывается по формуле \eqref{eq:us_rf}.
	\begin{equation}
		\label{eq:us_rf}
		f_{r} = 2 + N \cdot (2 + 4 + \frac{M}{2} \cdot (3 + 1 + 15)) = \frac{19}{2}NM + 6N + 2
	\end{equation}
	\item Трудоемкости вычисления массива $ColFactor$, которая рассчитывается, аналогично пункту 1, по формуле
	
	\begin{equation}
		\label{eq:us_rс}
		f_{c} = \frac{19}{2}LQ + 6L + 2
	\end{equation}
	
	\item Трудоемкости основной части алгоритма, которая вычисляется по формуле
	
	\begin{equation}
		\label{eq:us_vin_main}
		\begin{gathered}
		f_{main} = 2 + N \cdot (2 + 2 + L \cdot (2 + 7 + 4 + \frac{Q}{2} \cdot (4 + 28))) = \\
		= \frac{32}{2} NLQ + 13NL + 4N + 2
		\end{gathered}
	\end{equation}
	
	\item Трудоемкости поправки, вносимой для нечетного $Q$, рассчитываемой по следующей формуле
	
	\begin{equation}
		\label{eq:vin_error}
		f_{err} = 3 +
		\begin{cases}
			0, & \text{лучший случай}\\
			16LN + 4N + 2, & \text{худший случай}
		\end{cases}
	\end{equation}
	
\end{enumerate}

\clearpage

В итоге, трудоемкость алгоритма Винограда, вычисляется по формуле

\begin{equation}
	\label{eq:vinograd}
	\begin{gathered}
		f_{vinograd} = f_{r} + f_{c} + f_{main} + f_{err} = \frac{32}{2}NLQ + \frac{19}{2}LQ + \frac{19}{2} NM + \\
		+ 13NL + 10N + 6L + 9 + 
		\begin{cases}
			0, & \text{л.~с.}\\
			16LN + 4N + 2, & \text{х.~с.}
		\end{cases}
	\end{gathered}
\end{equation}


\subsection{Трудоемкость оптимизированного алгоритма Винограда}

Произведены следующие оптимизации алгоритма Винограда:
\begin{itemize}
	\item заменим операцию $x = x + k$ на $x += k$;
	\item заменим умножение на 2 на побитовый сдвиг;
	\item будем предвычислять некоторые слагаемые для алгоритма.
\end{itemize}

Трудоемкость оптимизированного алгоритма Винограда формируется из следующих частей.
\begin{enumerate}
	\item Трудоемкости вычисления массива $RowFactor$, которая рассчитывается по формуле
	
	\begin{equation}
		\label{eq:opt_rf}
		f_{r} = 3 + 2 + N \cdot (2 + 2 + \frac{M}{2} \cdot (2 + 11)) = \frac{13}{2}NM + 4N + 5
	\end{equation}
	
	\item Трудоемкости вычисления массива $ColFactor$, которая рассчитывается, аналогично пункту 1, по формуле
	
	\begin{equation}
		\label{eq:opt_rс}
		f_{c} = \frac{13}{2}LQ + 4L + 5
	\end{equation}
	
	\item Трудоемкости основной части алгоритма, которая вычисляется по формуле
	
	\begin{equation}
		\label{eq:opt_vin_main}
		\begin{gathered}
			f_{main} = 3 + 2 + N \cdot (2 + 2 + 3 + L \cdot (2 + 5 + 2 + \frac{Q}{2} \cdot (2 + 17))) = \\
			= \frac{21}{2} NLQ + 9NL + 7N + 5
		\end{gathered}
	\end{equation}
	
	\item Трудоемкости поправки, вносимой для нечетного $Q$, рассчитываемой по формуле 
	
	\begin{equation}
		\label{eq:opt_vin_error}
		f_{err} = 3 +
		\begin{cases}
			0, & \text{лучший случай}\\
			11LN + 4N + 4, & \text{худший случай}
		\end{cases}
	\end{equation}
	
\end{enumerate}


В итоге, трудоемкость оптимизированного алгоритма Винограда, вычисляется по формуле

\begin{equation}
	\label{eq:opt_vinograd}
	\begin{gathered}
		f_{vinograd} = f_{r} + f_{c} + f_{main} + f_{err} = \frac{21}{2}NLQ + \frac{13}{2}LQ + \frac{13}{2} NM + \\
		+ 9NL + 11N + 4L + 15 + 
		\begin{cases}
			0, & \text{л.~с.}\\
			11LN + 4N + 4, & \text{х.~с.}
		\end{cases}
	\end{gathered}
\end{equation}


\subsection{Трудоемкость алгоритма Штрассена}

Рассчитаем трудоемкость подпрограммы MSR, изображенной на рисунке \ref{img:msr}. 
Будем считать затраты на расширение размера матрицы незначительными. 
Также будем считать, что стоимость срезов равна $1$.

Трудоемкость сложения или вычитания двух матриц размера $N \times N$, рассчитывается по формуле

\begin{equation}
	\label{eq:matrix_sum}
	f_{sum}(N) = 2 + N \cdot (2 + 2 + N \cdot (2 + 8)) = 10N^2 + 4N + 2
\end{equation}

Тогда трудоемкость описывается рекуррентной формулой

\begin{equation}
	\label{eq:strassen_form}
	T(n) = 
	\begin{cases}
		7, & n == 1\\
		7T(\frac{n}{2}) + 18f_{sum}(\frac{n}{2}) + 65, & n > 1
	\end{cases}
\end{equation}

Тогда возможно рассчитать трудоемкость для матриц порядка $n$ по формуле

\begin{equation}
	\label{eq:strassen_comp}
	\begin{gathered}
		T(n) = 7^{\log_{2}{n}} T(1) + \sum_{i=0}^{(\log_{2}{n}) - 1} (7^i (18f_{sum}(\frac{n}{2 ^ {i + 1}}) + 65))
	\end{gathered}
\end{equation}


\section*{Вывод}
На основе теоретических данных, полученных из аналитического раздела были построены схемы требуемых алгоритмов. 
Была введена модель оценки трудоемкости алгоритма, были рассчитаны трудоемкости алгоритмов в соответствии с этой моделью.

В результате теоретической оценки трудоемкостей алгоритмов выяснилось, что самой маленькой асимптотической сложностью обладает алгоритм Штрассена $O(n^{\log_2{7}})$. 

Трудоемкость алгоритмов Винограда без оптимизаций, с оптимизациями и классического алгоритма оценивается как $O(NLQ)$. 
Но у этих алгоритмов различные мультипликаторы: 16, 21/2 и 11 соответственно.
Значит, с учетом мультипликаторов оценка трудоемкости алгоритма Винограда без оптимизаций больше, чем оценка трудоемкости классического алгоритма.
Но при этом с учетом мультипликаторов оценка трудоемкости алгоритма Винограда с оптимизациями меньше, чем оценка трудоемкости классического алгоритма.